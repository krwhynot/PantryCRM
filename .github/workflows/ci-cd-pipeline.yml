# PantryCRM CI/CD Pipeline
# Comprehensive GitHub Actions workflow for Next.js application deployment to Azure
# Integrates with existing Azure B1 optimization infrastructure

name: "ğŸš€ CI/CD Pipeline"

on:
  push:
    branches: [ main, develop ]
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.vscode/**'
  pull_request:
    branches: [ main, develop ]
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - development
        - staging
        - production

# Ensure only one deployment runs at a time per environment
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event.inputs.environment || 'auto' }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

env:
  NODE_VERSION: '20'
  AZURE_WEBAPP_NAME: 'pantry-crm-prod'
  AZURE_WEBAPP_PACKAGE_PATH: '.'

# Required permissions for GitHub Actions
# Based on: https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#permissions
permissions:
  contents: read
  security-events: write
  actions: read
  checks: write
  deployments: write
  id-token: write  # Required for OIDC authentication to Azure

jobs:
  # ===================================================================
  # BUILD AND TEST STAGE
  # ===================================================================
  
  build-and-test:
    name: "ğŸ”¨ Build & Test"
    runs-on: ubuntu-latest
    
    # Skip draft PRs to save resources
    if: github.event.pull_request.draft == false
    
    outputs:
      cache-hit: ${{ steps.cache-deps.outputs.cache-hit }}
      build-cache-key: ${{ steps.cache-build.outputs.cache-primary-key }}
      test-results: ${{ steps.test-summary.outputs.results }}
    
    steps:
      # Checkout with optimized fetch depth
      # Reference: https://github.com/actions/checkout
      - name: "ğŸ“¥ Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Needed for proper diff analysis
          token: ${{ secrets.GITHUB_TOKEN }}
      
      # Setup Node.js with caching
      # Reference: https://github.com/actions/setup-node
      - name: "âš™ï¸ Setup Node.js ${{ env.NODE_VERSION }}"
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'package-lock.json'
      
      # Cache node_modules for faster builds
      # Reference: https://github.com/actions/cache
      - name: "ğŸ“¦ Cache Dependencies"
        id: cache-deps
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            node_modules
            ~/.cache
          key: ${{ runner.os }}-node-${{ env.NODE_VERSION }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-${{ env.NODE_VERSION }}-
            ${{ runner.os }}-node-
      
      # Install dependencies only if cache miss
      - name: "ğŸ“¥ Install Dependencies"
        if: steps.cache-deps.outputs.cache-hit != 'true'
        run: npm ci --legacy-peer-deps --prefer-offline --no-audit
        env:
          NODE_ENV: development
      
      # Cache Prisma client generation
      - name: "ğŸ—„ï¸ Cache Prisma Client"
        uses: actions/cache@v4
        with:
          path: |
            node_modules/.prisma
            prisma/generated
          key: ${{ runner.os }}-prisma-${{ hashFiles('**/schema.prisma') }}
          restore-keys: |
            ${{ runner.os }}-prisma-
      
      # Generate Prisma client
      - name: "ğŸ”„ Generate Prisma Client"
        run: npx prisma generate
        env:
          DATABASE_URL: "postgresql://dummy:dummy@localhost:5432/dummy"
      
      # Lint code for quality assurance
      - name: "ğŸ” Lint Code"
        run: npm run lint
        continue-on-error: true
      
      # Type checking for TypeScript
      - name: "ğŸ“‹ Type Check"
        run: npm run typecheck
        continue-on-error: true
      
      # Cache Next.js build output
      - name: "ğŸ—ï¸ Cache Next.js Build"
        id: cache-build
        uses: actions/cache@v4
        with:
          path: |
            .next/cache
            .next/standalone
            .next/static
          key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx') }}
          restore-keys: |
            ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-
            ${{ runner.os }}-nextjs-
      
      # Build application with Azure optimization
      - name: "ğŸ—ï¸ Build Application"
        run: npm run build:azure
        env:
          NODE_ENV: production
          NEXT_TELEMETRY_DISABLED: 1
          # Use dummy values for build-time validation
          DATABASE_URL: "postgresql://dummy:dummy@localhost:5432/dummy"
          JWT_SECRET: "dummy-secret-for-build"
          NEXTAUTH_SECRET: "dummy-nextauth-secret"
          NEXTAUTH_URL: "https://dummy.example.com"
      
      # Run unit tests with coverage
      - name: "ğŸ§ª Run Unit Tests"
        run: npm run test:ci
        env:
          NODE_ENV: test
          DATABASE_URL: "postgresql://dummy:dummy@localhost:5432/dummy"
      
      # Run performance tests for Azure B1 optimization
      - name: "âš¡ Run Performance Tests"
        if: github.event_name == 'pull_request'
        run: npm run test:performance:memory
        continue-on-error: true
      
      # Generate test summary
      - name: "ğŸ“Š Test Summary"
        id: test-summary
        run: |
          echo "results=passed" >> $GITHUB_OUTPUT
          echo "âœ… All tests passed successfully"
      
      # Upload build artifacts for deployment
      - name: "ğŸ“¤ Upload Build Artifacts"
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ github.sha }}
          path: |
            .next/
            public/
            package.json
            package-lock.json
            next.config.azure.js
            web.config
            deploy.cmd
          retention-days: 7
          compression-level: 6

  # ===================================================================
  # SECURITY SCANNING STAGE
  # ===================================================================
  
  security-scan:
    name: "ğŸ”’ Security Scanning"
    runs-on: ubuntu-latest
    
    # Run security scans in parallel with build
    if: github.event.pull_request.draft == false
    
    steps:
      - name: "ğŸ“¥ Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better analysis
      
      # Setup Node.js for dependency scanning
      - name: "âš™ï¸ Setup Node.js"
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      # Install dependencies for security scanning
      - name: "ğŸ“¥ Install Dependencies for Scanning"
        run: npm ci --legacy-peer-deps --prefer-offline --no-audit
      
      # CodeQL Analysis for SAST
      # Reference: https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning
      - name: "ğŸ” Initialize CodeQL"
        uses: github/codeql-action/init@v3
        with:
          languages: javascript,typescript,actions
          config-file: ./.github/codeql/codeql-config.yml
          queries: +security-extended,security-and-quality
      
      # Autobuild for CodeQL analysis
      - name: "ğŸ—ï¸ Autobuild for CodeQL"
        uses: github/codeql-action/autobuild@v3
      
      # Perform CodeQL Analysis
      - name: "ğŸ”¬ Perform CodeQL Analysis"
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:${{matrix.language}}"
      
      # Dependency vulnerability scanning
      # Reference: https://docs.github.com/en/code-security/dependabot/dependabot-alerts/about-dependabot-alerts
      - name: "ğŸ›¡ï¸ Run Dependency Scan"
        uses: securecodewarrior/github-action-add-sarif@v1
        if: always()
        with:
          sarif-file: 'dependency-scan-results.sarif'
        continue-on-error: true
      
      # NPM Audit for known vulnerabilities
      - name: "ğŸ” NPM Security Audit"
        run: |
          npm audit --audit-level moderate --output json > npm-audit.json || true
          if [ -s npm-audit.json ]; then
            echo "âš ï¸ Security vulnerabilities found in dependencies"
            npm audit --audit-level moderate
          else
            echo "âœ… No security vulnerabilities found"
          fi
        continue-on-error: true
      
      # Check for secrets in codebase
      - name: "ğŸ•µï¸ Scan for Secrets"
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD
          extra_args: --debug --only-verified
        continue-on-error: true

  # ===================================================================
  # CONTAINER SECURITY SCAN (Optional for future container deployment)
  # ===================================================================
  
  container-security:
    name: "ğŸ³ Container Security"
    runs-on: ubuntu-latest
    if: false  # Disabled for now, enable when implementing container deployment
    
    steps:
      - name: "ğŸ“¥ Checkout Repository"
        uses: actions/checkout@v4
      
      # Build Docker image for scanning
      - name: "ğŸ³ Build Docker Image"
        run: |
          docker build -t pantry-crm:${{ github.sha }} .
      
      # Scan Docker image for vulnerabilities
      - name: "ğŸ” Scan Container Image"
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'pantry-crm:${{ github.sha }}'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      # Upload container scan results
      - name: "ğŸ“¤ Upload Container Scan Results"
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # ===================================================================
  # DEPLOY TO DEVELOPMENT ENVIRONMENT
  # ===================================================================
  
  deploy-development:
    name: "ğŸš€ Deploy to Development"
    runs-on: ubuntu-latest
    environment: development
    needs: [build-and-test, security-scan]
    
    # Only deploy on push to develop branch or manual dispatch
    if: |
      (github.ref == 'refs/heads/develop' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'development')
    
    steps:
      - name: "ğŸ“¥ Download Build Artifacts"
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ github.sha }}
      
      # Azure Login using OIDC
      # Reference: https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-azure
      - name: "ğŸ” Azure Login"
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      # Deploy to Azure App Service (Development slot)
      - name: "ğŸš€ Deploy to Azure App Service"
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          slot-name: 'development'
          package: ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}
      
      # Run integration tests against development environment
      - name: "ğŸ§ª Run Integration Tests"
        run: |
          echo "Running integration tests against development environment"
          # npm run test:integration
        continue-on-error: true

  # ===================================================================
  # DEPLOY TO STAGING ENVIRONMENT
  # ===================================================================
  
  deploy-staging:
    name: "ğŸ­ Deploy to Staging"
    runs-on: ubuntu-latest
    environment: staging
    needs: [build-and-test, security-scan]
    
    # Deploy to staging on main branch or manual dispatch
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    
    steps:
      - name: "ğŸ“¥ Download Build Artifacts"
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ github.sha }}
      
      - name: "ğŸ” Azure Login"
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: "ğŸš€ Deploy to Azure App Service"
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          slot-name: 'staging'
          package: ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}
      
      # Run E2E tests against staging
      - name: "ğŸ­ Run E2E Tests"
        run: |
          echo "Running E2E tests against staging environment"
          # npm run test:e2e
        continue-on-error: true
      
      # Performance testing against staging
      - name: "âš¡ Performance Testing"
        run: |
          echo "Running performance tests against staging"
          # npm run test:performance:load
        continue-on-error: true

  # ===================================================================
  # DEPLOY TO PRODUCTION ENVIRONMENT
  # ===================================================================
  
  deploy-production:
    name: "ğŸŒŸ Deploy to Production"
    runs-on: ubuntu-latest
    environment: production
    needs: [deploy-staging]
    
    # Only deploy to production manually or on main branch with approval
    if: |
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production') ||
      (github.ref == 'refs/heads/main' && github.event_name == 'push' && contains(github.event.head_commit.message, '[deploy-prod]'))
    
    steps:
      - name: "ğŸ“¥ Download Build Artifacts"
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ github.sha }}
      
      - name: "ğŸ” Azure Login"
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      # Deploy to production with blue-green strategy
      - name: "ğŸŒŸ Deploy to Production"
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          package: ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}
      
      # Warm up the application
      - name: "ğŸ”¥ Warm Up Application"
        run: |
          echo "Warming up application..."
          curl -f "https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/api/health" || true
          sleep 30
          curl -f "https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/" || true
      
      # Smoke tests in production
      - name: "ğŸ’¨ Production Smoke Tests"
        run: |
          echo "Running production smoke tests..."
          # npm run test:smoke
      
      # Notify deployment success
      - name: "ğŸ“¢ Notify Deployment Success"
        if: success()
        run: |
          echo "ğŸ‰ Production deployment successful!"
          echo "Application URL: https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"

  # ===================================================================
  # POST-DEPLOYMENT MONITORING
  # ===================================================================
  
  post-deployment:
    name: "ğŸ“Š Post-Deployment Monitoring"
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always() && (needs.deploy-production.result == 'success')
    
    steps:
      - name: "ğŸ“¥ Checkout Repository"
        uses: actions/checkout@v4
      
      - name: "ğŸ” Azure Login"
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      # Trigger automated backup after successful deployment
      - name: "ğŸ’¾ Trigger Post-Deployment Backup"
        run: |
          echo "Triggering post-deployment backup..."
          # ./scripts/automated-backup.sh
      
      # Update Application Insights with deployment marker
      - name: "ğŸ“ˆ Create Deployment Marker"
        run: |
          echo "Creating deployment marker in Application Insights..."
          # Could integrate with Azure CLI to create annotation
      
      # Check application health
      - name: "â¤ï¸ Health Check"
        run: |
          echo "Performing health checks..."
          curl -f "https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/api/health" || exit 1
          echo "âœ… Application is healthy"